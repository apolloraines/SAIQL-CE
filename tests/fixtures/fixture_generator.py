"""
Generate S/M/L test fixtures for DEL determinism testing.

Creates deterministic test files for programmatic formats:
- CSV, HTML, RTF

Binary formats (PDF, DOCX, PPTX, XLSX) require external libraries
and are not generated by this script.

Size tiers:
- Small (S): 1 page/section, minimal content
- Medium (M): 3-5 pages/sections, mixed content
- Large (L): 10+ pages/sections, complex structure
"""

import os
import io
import csv
import hashlib
from pathlib import Path
from typing import Dict, Any

# Deterministic seed content
SEED_TEXT = "Atlas determinism test fixture. This content must hash identically across runs."


def generate_csv_small() -> bytes:
    """Generate small CSV fixture."""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(["id", "name", "value"])
    writer.writerow(["1", "alpha", "100"])
    writer.writerow(["2", "beta", "200"])
    writer.writerow(["3", "gamma", "300"])
    return output.getvalue().encode("utf-8")


def generate_csv_medium() -> bytes:
    """Generate medium CSV fixture."""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(["id", "category", "product", "price", "quantity"])
    for i in range(50):
        writer.writerow([
            str(i + 1),
            f"cat_{(i % 5) + 1}",
            f"product_{i + 1}",
            f"{(i * 10) + 99}.99",
            str((i % 100) + 1)
        ])
    return output.getvalue().encode("utf-8")


def generate_csv_large() -> bytes:
    """Generate large CSV fixture."""
    output = io.StringIO()
    writer = csv.writer(output)
    headers = ["id", "timestamp", "category", "subcategory", "item", "value", "notes"]
    writer.writerow(headers)
    for i in range(500):
        writer.writerow([
            str(i + 1),
            f"2026-01-{(i % 28) + 1:02d}T{(i % 24):02d}:00:00Z",
            f"category_{(i % 10) + 1}",
            f"subcat_{(i % 25) + 1}",
            f"item_{i + 1}_deterministic_test_data",
            f"{i * 3.14159:.4f}",
            f"Note for row {i + 1}: {SEED_TEXT[:50]}"
        ])
    return output.getvalue().encode("utf-8")


def generate_html_small() -> bytes:
    """Generate small HTML fixture."""
    html = """<!DOCTYPE html>
<html>
<head>
    <title>Small Test Document</title>
</head>
<body>
    <h1>Test Heading</h1>
    <p>This is a simple test paragraph for determinism verification.</p>
    <p>Second paragraph with more content.</p>
</body>
</html>"""
    return html.encode("utf-8")


def generate_html_medium() -> bytes:
    """Generate medium HTML fixture."""
    sections = []
    for i in range(5):
        sections.append(f"""
    <section id="section-{i+1}">
        <h2>Section {i+1}: Topic Area</h2>
        <p>This is paragraph 1 of section {i+1}. It contains deterministic test content.</p>
        <p>This is paragraph 2 of section {i+1}. More content for extraction testing.</p>
        <ul>
            <li>Item {i+1}.1</li>
            <li>Item {i+1}.2</li>
            <li>Item {i+1}.3</li>
        </ul>
    </section>""")

    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Medium Test Document</title>
</head>
<body>
    <header>
        <h1>Medium Complexity Test Document</h1>
        <nav>
            <a href="#section-1">Section 1</a>
            <a href="#section-2">Section 2</a>
        </nav>
    </header>
    <main>
        {"".join(sections)}
    </main>
    <footer>
        <p>Footer content for determinism testing.</p>
    </footer>
</body>
</html>"""
    return html.encode("utf-8")


def generate_html_large() -> bytes:
    """Generate large HTML fixture."""
    articles = []
    for i in range(15):
        paragraphs = "\n".join([
            f"        <p>Article {i+1}, paragraph {j+1}: {SEED_TEXT}</p>"
            for j in range(5)
        ])
        articles.append(f"""
    <article id="article-{i+1}">
        <h2>Article {i+1}: Extended Topic</h2>
        <div class="meta">Published: 2026-01-{(i % 28) + 1:02d}</div>
{paragraphs}
        <table>
            <tr><th>Column A</th><th>Column B</th><th>Column C</th></tr>
            <tr><td>Data {i+1}.1</td><td>Data {i+1}.2</td><td>Data {i+1}.3</td></tr>
            <tr><td>Data {i+1}.4</td><td>Data {i+1}.5</td><td>Data {i+1}.6</td></tr>
        </table>
    </article>""")

    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Large Test Document</title>
</head>
<body>
    <header>
        <h1>Large Complexity Test Document</h1>
    </header>
    <main>
        {"".join(articles)}
    </main>
</body>
</html>"""
    return html.encode("utf-8")


def generate_rtf_small() -> bytes:
    """Generate small RTF fixture."""
    rtf = r"""{\rtf1\ansi\deff0
{\fonttbl{\f0 Times New Roman;}}
\f0\fs24
{\pard Test Heading\par}
{\pard This is a simple test paragraph for RTF extraction.\par}
{\pard Second paragraph with deterministic content.\par}
}"""
    return rtf.encode("utf-8")


def generate_rtf_medium() -> bytes:
    """Generate medium RTF fixture."""
    paragraphs = []
    for i in range(10):
        paragraphs.append(
            r"{\pard\b Section " + str(i + 1) + r"\b0\par}" +
            r"{\pard Paragraph content for section " + str(i + 1) +
            r". This is deterministic test content for extraction verification.\par}"
        )

    rtf = r"""{\rtf1\ansi\deff0
{\fonttbl{\f0 Times New Roman;}}
\f0\fs24
{\pard\b Medium RTF Document\b0\par}
""" + "\n".join(paragraphs) + r"""
}"""
    return rtf.encode("utf-8")


def generate_rtf_large() -> bytes:
    """Generate large RTF fixture."""
    sections = []
    for i in range(25):
        sections.append(
            r"{\pard\b Chapter " + str(i + 1) + r"\b0\par}" +
            r"{\pard " + SEED_TEXT + r"\par}" +
            r"{\pard Additional content for chapter " + str(i + 1) +
            r" with extended text for large fixture testing.\par}"
        )

    rtf = r"""{\rtf1\ansi\deff0
{\fonttbl{\f0 Times New Roman;}}
\f0\fs24
{\pard\b Large RTF Document - Determinism Test\b0\par}
""" + "\n".join(sections) + r"""
}"""
    return rtf.encode("utf-8")


def compute_hash(data: bytes) -> str:
    """Compute SHA-256 hash of data."""
    return hashlib.sha256(data).hexdigest()


def generate_all_fixtures(base_dir: Path) -> Dict[str, Dict[str, Any]]:
    """Generate all fixtures and return manifest."""
    manifest = {}

    # CSV fixtures
    fixtures = [
        ("small/test_small.csv", generate_csv_small()),
        ("medium/test_medium.csv", generate_csv_medium()),
        ("large/test_large.csv", generate_csv_large()),
        ("small/test_small.html", generate_html_small()),
        ("medium/test_medium.html", generate_html_medium()),
        ("large/test_large.html", generate_html_large()),
        ("small/test_small.rtf", generate_rtf_small()),
        ("medium/test_medium.rtf", generate_rtf_medium()),
        ("large/test_large.rtf", generate_rtf_large()),
    ]

    for rel_path, data in fixtures:
        full_path = base_dir / rel_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_bytes(data)

        manifest[rel_path] = {
            "size_bytes": len(data),
            "sha256": compute_hash(data),
        }

    return manifest


if __name__ == "__main__":
    base = Path(__file__).parent
    manifest = generate_all_fixtures(base)

    print("Generated fixtures:")
    for path, info in sorted(manifest.items()):
        print(f"  {path}: {info['size_bytes']} bytes, sha256={info['sha256'][:16]}...")

    # Write manifest
    import json
    manifest_path = base / "fixture_manifest.json"
    with open(manifest_path, "w") as f:
        json.dump(manifest, f, indent=2, sort_keys=True)
    print(f"\nManifest written to: {manifest_path}")
